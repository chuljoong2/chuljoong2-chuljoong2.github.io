---
layout: post
title: "3주차 과제"
date: 2022-03-24 13:23:55 +0900
---

# 분할 정복 알고리즘

주어진 문제의 입력을 분할하여 문제를 해결(정복)하는 방식의 알고리즘이다. 이때 분할된 입력에 대하여 동일한 알고리즘을 적용하여 해를 계산해야한다.

분할된 입력에 대한 문제를 부분문제라고 하고, 부분문제의 해를 부분해라고 한다. 부분문제는 더 이상 분할할 수 없을 때까지 계속 분할한다.

## 합병 정렬

문제가 **2개의 부분문제로 분할**되고, **부분문제의 크기가 1/2로 감소**하는 분할 정복 알고리즘이다. 각각의 부분문제를 재귀적으로 합병 정렬한 후 2개의 정렬된 부분을 합병하여 정렬하는 방법을 합병 정렬(Merge Sort)라고 한다.

연결 리스트에 있는 데이터를 정렬할 때 퀵 정렬이나 힙 정렬보다 훨씬 효율적이라고 한다.

### 과정

![https://user-images.githubusercontent.com/63987872/159892561-0e828f85-820c-44bc-89f6-b85c29072b04.png](https://user-images.githubusercontent.com/63987872/159892561-0e828f85-820c-44bc-89f6-b85c29072b04.png)

맨 위에 정렬되지 않은 **원소의 개수가 8인 배열이 있다.** 저 배열을 정렬하기 위해 **반으로 나누어 다시 합병정렬을 할 수 있다.**

- 1번 과정
  `37 10 22 30`
  반으로 나누었다. 이 배열을 정렬하기 위한 방법 또한 반으로 나누어 다시 합병 정렬을 수행하는 것이다.
- 2번 과정
  `37 10`
  역시 반으로 나누었지만 이 배열을 정렬하기 위한 벙법 또한 반으로 나누어 다시 합병 정렬을 수행하는 것이다. 이 과정은 원소의 개수가 1이 될 때 까지 반복한다.
- 3번 ~ 4번 과정
  `37` `10`
  이제 원소의 개수가 1이 되었다. 원소의 개수 2일 때의 배열 [37, 10]의 왼쪽과 오른쪽이 정렬된 것이다. (원소의 개수가 1이므로 정렬된 것이라고 볼 수 있다.)
  여기서부터는 더 이상 반으로 나눌 수 없으니 이제 **합병(정복)하는 과정**에 들어가야 한다.
- 5번 과정
  두 원소의 크기를 비교해 오름차순으로 임시배열에 삽입한다.
  `10 37`
- 6번 ~ 9번 과정
  **원소의 개수 4**일 때 왼쪽 배열을 정렬했으니, 이제 오른쪽 배열을 위와 같은 과정을 거쳐 정렬해야한다. 그 결과 배열은 아래와 같이 나온다.
  `22 30`
- 10번 과정
  왼쪽과 오른쪽을 정렬했다면, 이제 **왼쪽 배열과 오른쪽 배열의 원소를 하나하나 비교**해 작은 것부터 다시 넣는다.
  `10 22 30 37`
- 11번 ~ 21번 과정
  이렇게 되면 **원소의 개수 8**일 때의 왼쪽 배열을 정렬한 것이다. 이제 **원소의 개수 8**일 때의 오른쪽 배열 [35, 13, 25, 24]도 위와 같은 과정을 거쳐 아래와 같이 정렬된다면, 이 왼쪽 배열[10, 22, 30, 37]과 비교해서 배열을 완성하면 된다.
  `13 24 25 35`

이와 같은 과정을 거치면 정렬을 다한 것이다.

한 마디로 요약하자면, 정렬되지 않은 배열을 받으면 그냥 **원소의 개수가 1이 될 때까지 반으로 계속 나누다가, 원소의 개수가 1이 된다면 그때부터 나눠왔던 원소들의 값을 비교해서 합쳐서 정렬하는 방법**이다.

### 수도코드

```
MergeSort(A, p, q)
입력: A[p] ~ A[q]
출력: 정렬된 A[p] ~ A[q]

if p < q 라면,
		k = (p + q) // 2
		MergeSort(A, p, k)
		MergeSort(A, k+1, q)

		정렬된 A[p] ~ A[k]와 A[k + 1] ~ A[q]를 합병
```

- line 1: p는 q를 절대 역전할 수 없지만 같아질 수 는 있다. 즉, 정렬할 부분의 원소의 수가 2개 이상일때만 다음단계가 수행한다. 만약 p == q인 경우에는 원소의 수가 1인거고 그 자체로 정렬된 것이므로 line 2 ~ 5는 수행되지 않는다.
- line 2: 부분문제의 크기를 1/2로 감소해야 한다. 정렬할 부분의 원소들을 1/2로 나누기 위해 k = (p + q) // 2를 계산한다. 이 계산을 통하여 원소의 홀수일 때도 소수점 이하를 버려 정수부분만 남긴다.
- line 3 ~ 4: 앞 부분 MergeSort(A, p, k)와 뒷 부분 MergeSort(A, k + 1, q)을 재귀 호출하여 각각 정렬한다.
- line 5: line 3 ~ 4에서 정렬된 부분을 합병한다. 합병 과정의 마지막에는 임시 배열에 있는 합병된 원소들을 배열 A로 복사한다. 즉, 임시 배열 B[p] ~ B[q]를 A[p] ~ A[q]로 복사한다.

### 파이썬 코드

```python
sublist = [37, 10, 22, 30, 35, 13, 25, 24]

def mergeSort(list):
  size = len(list)

  if size <= 1:
    return list

  mid = len(list) // 2

  left = mergeSort(list[:mid])

  right = mergeSort(list[mid])

  merged = merge(left, right)

  return merged

def merge(list1, list2):
  merged = []

  while len(list1) > 0 and len(list2) > 0:
    if list1[0] <= list2[0]:
      merged.append(list1.pop(0))
    else:
      merged.append(list2.pop(0))

  if len(list1) > 0:
    merged += list1

  if len(list2) > 0:
    merged += list2

  return merged

sorted = mergeSort(sublist)

print(sorted)
```

### 시간 복잡도

**정렬의 시간복잡도는 일반적으로 숫자의 비교 횟수**로 나타낸다.

- 분할하는 부분
  분할하는 부분은 배열의 인덱스 계산과 2번의 재귀호출을 하는 것이므로 O(1)의 시간이 걸린다.
- 합병하는 부분
  - 두 정렬된 배열 A, B의 크기가 각각 n과 m이고 이를 합병하여 새로운 배열 C를 만드는 부분
    (n + m - 1)번의 비교를 통해 배열 C를 채우므로 시간 복잡도는 O(n + m)이다.
  - 층 별 비교
    각 층에서 수행되는 비교 횟수는 분할된 크기 \* 분할된 개수로 항상 O(n)이다. 그리고 층 수는 log2n이므로 모든 층에서 수행되는 비교 횟수는 O(nlog2n)이다.

결과적으로 합병정렬의 시간복잡도는 O(nlog2n)이 된다.

### 공간 복잡도

공간복잡도는 합병된 결과를 저장할 입력 크기와 같은 **임시 배열이 하나 더 필요하기 때문에** **공간 복잡도는 O(n**)이다.

**대부분의 정렬 알고리즘들은 입력을 위한 메모리 공간과 O(1) 크기의 메모리 공간**만을 사용하면서 정렬 수행하기 때문에 이는 합병 정렬의 단점이기도 하다.
O(1) 크기의 메모리 공간이란, 입력 크기 n과 상관 없는 크기의 공간. ex) 변수, 인덱스 등
